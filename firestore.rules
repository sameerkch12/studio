/**
 * Core Philosophy: This ruleset enforces a hybrid security model. The primary model is strict
 * user ownership, where "delivery boys" can only access their own data. This is supplemented
 * by a global admin role, which grants read/write access to all user data for
 * management and oversight purposes.
 *
 * Data Structure: The data is hierarchically organized under the `/delivery_boys/{deliveryBoyId}`
 * collection, where `deliveryBoyId` corresponds to a user's authentication UID. All personal
 * data, such as delivery and payment records, are stored in subcollections under this path.
 * A separate top-level collection, `/roles_admin`, is used to manage admin privileges.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is explicitly granted.
 * - User Data Privacy: Users (delivery boys) can only access documents within their own
 *   data tree (i.e., `/delivery_boys/{their_own_uid}/...`). Listing of all delivery boys
 *   is prohibited to protect user privacy.
 * - Admin Override: Users with an admin role (defined by a document in `/roles_admin`) have
 *   full read and write access to all `delivery_boys` data.
 * - Privilege Escalation Prevention: The `/roles_admin` collection is protected. Only existing
 *   admins can view, grant, or revoke admin privileges, preventing unauthorized users from
 *   elevating their own permissions. The creation of the first admin must be done manually
 *   via the Firebase Console.
 *
 * Denormalization for Authorization: This ruleset uses path-based ownership for all user-
 * specific data, which avoids the need for extra `get()` calls to check permissions. For
 * example, a rule on `/delivery_boys/{deliveryBoyId}/delivery_records/{recordId}` can check
 * ownership directly from the `deliveryBoyId` in the path. Admin roles are checked with a single,
 * efficient `exists()` call, which is a standard and performant pattern for role-based access control.
 *
 * Structural Segregation: User data is naturally segregated by the `/delivery_boys/{deliveryBoyId}`
 * structure. Admin role data is kept in a separate `/roles_admin` collection, ensuring that
 * security rules for user data and administrative data are simple and distinct.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------------------

    /**
     * Returns true if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Returns true if the authenticated user's UID matches the provided userId.
     * This is the primary function for checking document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Returns true if a document for the requesting user exists in the admin roles collection.
     * This check is efficient and does not count as a read for billing purposes.
     */
    function isAdmin() {
      return isSignedIn() && exists(/databases/$(database)/documents/roles_admin/$(request.auth.uid));
    }

    /**
     * Combines owner and admin checks for rules that grant access to either.
     */
    function isOwnerOrAdmin(userId) {
      return isOwner(userId) || isAdmin();
    }

    /**
     * Ensures a document exists before an update or delete operation.
     * This prevents operations on non-existent documents.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * On create, validates that the incoming document's ID field matches the path.
     * This establishes the ownership link within the document itself.
     */
    function ownerIdMatchesPathOnCreate(userId) {
      return request.resource.data.id == userId;
    }

    /**
     * On update, ensures the document's ID field cannot be changed.
     * This makes the ownership link immutable.
     */
    function ownerIdIsImmutable() {
      return request.resource.data.id == resource.data.id;
    }

    /**
     * On create, validates that a foreign key (e.g., deliveryBoyId) in a subcollection
     * document correctly points back to the parent document's ID in the path.
     */
    function parentIdMatchesPathOnCreate(userId) {
      return request.resource.data.deliveryBoyId == userId;
    }

    /**
     * On update, ensures the foreign key linking a subcollection document
     * to its parent is immutable.
     */
    function parentIdIsImmutable() {
      return request.resource.data.deliveryBoyId == resource.data.deliveryBoyId;
    }

    // --------------------------------------------------------------------------------
    // Collection Rules
    // --------------------------------------------------------------------------------

    /**
     * @description Manages admin privileges. The existence of a document grants admin rights.
     * @path /roles_admin/{userId}
     * @allow An existing admin (auth.uid=`admin1`) creating a new admin doc at `/roles_admin/newUser123` (create).
     * @deny A non-admin user (auth.uid=`user1`) trying to read or create a doc at `/roles_admin/user1` (get, create).
     * @principle Prevents privilege escalation by restricting role management to existing admins.
     */
    match /roles_admin/{userId} {
      allow get: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin();
      allow update: if isAdmin() && isExistingDoc();
      allow delete: if isAdmin() && isExistingDoc();
    }

    /**
     * @description Stores the main profile for a delivery boy.
     * @path /delivery_boys/{deliveryBoyId}
     * @allow A new user (auth.uid=`newBoy123`) creating their own profile at `/delivery_boys/newBoy123` (create).
     * @deny A user (auth.uid=`userXYZ`) trying to update another user's profile at `/delivery_boys/userABC` (update).
     * @principle Enforces self-creation for profiles and owner/admin-only modifications. Disallows listing of all users.
     */
    match /delivery_boys/{deliveryBoyId} {
      allow get: if isOwnerOrAdmin(deliveryBoyId);
      allow list: if false;
      allow create: if isOwner(deliveryBoyId) && ownerIdMatchesPathOnCreate(deliveryBoyId);
      allow update: if (isOwnerOrAdmin(deliveryBoyId) && isExistingDoc()) && ownerIdIsImmutable();
      allow delete: if isOwnerOrAdmin(deliveryBoyId) && isExistingDoc();

      /**
       * @description Stores daily delivery records for a specific delivery boy.
       * @path /delivery_boys/{deliveryBoyId}/delivery_records/{deliveryRecordId}
       * @allow The owner (auth.uid=`boy123`) creating a record at `/delivery_boys/boy123/delivery_records/rec456` (create).
       * @deny A different user (auth.uid=`boyXYZ`) trying to list records from `/delivery_boys/boy123/delivery_records` (list).
       * @principle Restricts access to a user's own data tree, with admin override for management.
       */
      match /delivery_records/{deliveryRecordId} {
        allow get: if isOwnerOrAdmin(deliveryBoyId);
        allow list: if isOwnerOrAdmin(deliveryBoyId);
        allow create: if isOwnerOrAdmin(deliveryBoyId) && parentIdMatchesPathOnCreate(deliveryBoyId);
        allow update: if (isOwnerOrAdmin(deliveryBoyId) && isExistingDoc()) && parentIdIsImmutable();
        allow delete: if isOwnerOrAdmin(deliveryBoyId) && isExistingDoc();
      }

      /**
       * @description Stores payment records for a specific delivery boy.
       * @path /delivery_boys/{deliveryBoyId}/payment_records/{paymentRecordId}
       * @allow An admin creating a payment record for user `boy123` at `/delivery_boys/boy123/payment_records/pay789` (create).
       * @deny A user (auth.uid=`boyXYZ`) trying to delete a record from `/delivery_boys/boy123/payment_records/pay789` (delete).
       * @principle Restricts access to a user's own data tree, with admin override for management.
       */
      match /payment_records/{paymentRecordId} {
        allow get: if isOwnerOrAdmin(deliveryBoyId);
        allow list: if isOwnerOrAdmin(deliveryBoyId);
        allow create: if isOwnerOrAdmin(deliveryBoyId) && parentIdMatchesPathOnCreate(deliveryBoyId);
        allow update: if (isOwnerOrAdmin(deliveryBoyId) && isExistingDoc()) && parentIdIsImmutable();
        allow delete: if isOwnerOrAdmin(deliveryBoyId) && isExistingDoc();
      }
    }
  }
}